Chapter 2.1 数组
--->P8, #26. Remove Duplicates from Sorted Array
way 1:
	two pointers:
	a. check if the array is empty
	b. ++index 永远都是新array的size
way 2:
	使用STL
	distance( InputIt first, InputIt last ); //The number of increments needed to go from first to last. The value may be negative if random-access iterators are used and first is reachable from last 
	std::unique(v.begin(), v.end()); //std::unique is used to replaced duplicates of any element present consecutively in a range[first, last) by garbage and return the last valid iterator. unique(...) does not remove duplicates, instead the duplicates are replaced by *** garbage, so we need to resize it after "unique" it. 
Way 3: 
	P9, 代码3 用upper_bound(first, last, *first) to return the 1st element which is greater than "first" and then assign it to the first because the elements have been sorted, so the duplicated can be skipped. Assign all new "first" to the new output array//It returns an iterator pointing to the first element in the range [first, last) that is greater than value, or last if no such element is found. The elements in the range shall already be sorted or at least partitioned with respect to val.
--->P9, #80.  Remove Duplicates from Sorted Array II
way 1: 
	可改变index and i initial value to change the max allowed repeat times: index 和i的initial value 都是一样的， 2开始，记录新array的（最后一个element位置-1)， i也从2开始知道array.size，和当前array的(index-2) 对比. 注意这里的index直接return，不需要加减，这时index=size of array 因为index从0开始，所以本来就比size of array少一个，最后++正好补上
way 2:
	邻近三个数相比较，如果一样就不让index增加，index永远指在可能要被替代的下一个数上
	"continue" forces the next iteration of the loop to take place
--->P11, #33 Search in Rotated Sorted Array
way 1: 
	Binary search
	1.if nums[first]<=nums[mid],那么first to mid will be monotonically increasing(单调递增) and nums[first]<=target<nums[mid]: search 前半段 last=mid,不然search后半段 first = mid+1
	2. if nums[first]>nums[mid] and nums[mid]<target<=nums[last-1]: search 后半段，反之search前半段

	Algorithm from GeeksForGeeks:
	Input arr[] = {3, 4, 5, 1, 2}
	Element to Search = 1
	  1) Find out pivot point and divide the array in two sub-arrays. (pivot = 2) /*Index of 5*/
	  2) Now call binary search for one of the two sub-arrays.
	      (a) If element is greater than 0th element then search in left array
	      (b) Else Search in right array (1 will go in else as 1 < 0th element(3))
	  3) If element is found in selected sub-array then return index
	     Else return -1.
--->P12, #81 Search in Rotated Sorted Array II (allow duplicates)
way 1: 
	把之前nums[first]<=nums[mid]拆成两个条件：
	nums[first]<nums[mid]： 单调递增
	nums[first]==nums[mid]： 增加first++ 判断下一个
!!!Review--->p13, #4. Median of Two Sorted Arrays
	see reference, 对比 A[k/2-1] and B[k/2-1], 然后把小于的那部分array A 或 B [0:k/2-1]删除
	if (total & 0X1) // It's doing a bitwise AND on the least-significant bit of "total". If it returns true (ie, that bit is set), then thenumber is odd. Otherwise, it's even. e.g. (5) 0101 & 0001 == 1 (odd, true); (6) 0110 & 0001 == 0 (even, false)
	1. 判断total奇偶
	2. 递归中介的三种情况：m>n; m==0空集；k==1;
	3. divide k into two parts: 
	int ia = min(k / 2, m), ib = k - ia;
	A[ia-1]<B[ib-1]; >; == 
--->p14, #128 Longest Consecutive Sequence
way1:
	让iterator和之前和之后对比是否连续 
	1. length 从1开始！
	2. 在for loop中不能忘了把当前iterator变成true！for loop 中ending注意条件是return的pointer不是used.end()，如果没找到就return null pointer
	3. 从i向前/后找连续的下一个数,一个一个iterate，同时把iterator过得used[i]变true
!!!Review way2:
	1. create unordered_map<int, int> map to store nums
	2. length is also starting from 1
	3. for loop to iterate every element in the nums
	4. assign 1 to each not-found element to map
	5. find if the previous conssecutive item is in the map, if yes, put previous and current consecutive into mergeCluster function
	6. length = max (length, return from mergeCluster)
	7. inside mergeCluster(map, left, right) //to caculate the smallest and the largest number in this consecutive sequence
	int upper = right + map[right] - 1;
	int lower = left - map[left] + 1;
--->p16, #1. Two Sum
way2: hash table 
	1. unordered_map <int, int> map=>[value, index]
	2. for loop to iterate each element and use target-nums[i] to caculate the gap
	3. find the gap in the map && map[gap] > i
	4. if find it, return the index i and map[gap] and break it
-->p18, #15. 3Sum
way1: 
	1. check nums.size() >= 3, 排序 vector
	2. don't forgot compare if *i == *(i-1), if there is repeat elements, no need to rerun.
	3. j<k should be a while loop inside the for loop of i instead of putting into the if statement
	4. 最小的两个数和最后一个数相加夹击找出和等于target： sum<target=>j++; sum>target=>k--; sum=target=>push_back (*i, *j, *k)
	5. after find sum == target, because there should not be duplicates, we increase both j and k
	4. if下一个*j && 前一个*k 值不变 && j<k，j++
Chapter 2.2 Linked List
--->p46, #2. Add Two Numbers
	Similar with --->p67, #67. Add Binary
	self write: 
	/**
	 * Definition for singly-linked list.
	 * struct ListNode {
	 *     int val;
	 *     ListNode *next;
	 *     ListNode(int x) : val(x), next(NULL) {}
	 * };
	 */
	class Solution {
	public:
	    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
	        ListNode* curr1 = l1;
	        ListNode* curr2 = l2;
	        ListNode dummy(-1);
	        ListNode* new_node = &dummy;
	        int carry = 0;
	        while (curr1 != NULL || curr2 != NULL){
	            int r1 = (curr1 != NULL)? curr1->val : 0;
	            int r2 = (curr2 != NULL)? curr2->val : 0;
	            int sum = (r1+r2+carry)%10;
	            carry = (r1+r2+carry)/10;
	            new_node->next = new ListNode(sum);
	            new_node = new_node->next;
	            if (curr1 != NULL) curr1 = curr1->next;
	            if (curr2 != NULL) curr2 = curr2->next;
	        }
	        if (carry>0) new_node->next = new ListNode(carry);
	        return dummy.next;
	    }
	};
-->p47, #92. Reverse Linked List II
Way1: (failed)
	1. Find the address of start and end position of the lined list by running a loop
	2. Unlink this part from the rest of the list 
	3. use the normal liked list reverse function
	4. attached the portion reversed to the main 
Way2: 
	1. find the mth node position
	for(int i=1; i<m; i++)
	2. reverse it from m to n (need prev [Node *prev], curr [Node *curr], node before reversed starting point [Node **head]
	3. return

	similar easy: #206. Reverse Linked List: 
	public:
    ListNode* reverseList(ListNode* head) {
    if (head == NULL || head->next == NULL) return head;
    ListNode* p = reverseList(head->next);
    head->next->next = head;
    head->next = NULL;
    return p;
    }
--->p56, #138. (DeepCopy)Copy List with Random Pointer:
	Deep copy:(pointers must not be copied, in deep copy, we are copying the entire object,  creating a new pointer pointing to the new memory address, never copy the pointer! Using “new” to create a new pointer and store the dereferenced data of the old pointer to this new pointer with new memory address. We can not simply copy the pointer using “=”.
Way1: 
	Method 2 (Uses Constant Extra Space)
	Thanks to Saravanan Mani for providing this solution. This solution works using constant space.
	1) Create the copy of node 1 and insert it between node 1 & node 2 in original Linked List, create the copy of 2 and insert it between 2 & 3.. Continue in this fashion, add the copy of N afte the Nth node
	2) Now copy the arbitrary link in this fashion
	     original->next->arbitrary = original->arbitrary->next;  /*TRAVERSE 
	TWO NODES*/ Need to check if the random pointer is NULL
	This works because original->next is nothing but copy of original and Original->arbitrary->next is nothing but copy of arbitrary.
	3) Now restore the original and copy linked lists in this fashion in a single loop.
	     original->next = original->next->next;
	     copy->next = copy->next->next;
	4) Make sure that last element of original->next is NULL.
Chapter 3 Strings
--->p67, #67. Add Binary
	size_t: represent the size of any object in bytes.
	Algorithm: Carry （用reminder） 和那一位的digit（结果除以2--如果是binary）结果要注意 The idea is to start from last characters of two strings and compute digit sum one by one. If sum becomes more than 1, then store carry for next digits.
	1. check the size of the longest string
	2. reverse the string OR for loop starting from i=size-1 and i>=0 || j>=0
	3. compare each digit sum with "0" ASCII value
	4. calcualte digit of the result and the carry in each final digit
	5. check if there is carry in the MSB
	sum%2=1 可以判断哪个digit是1(odd)
	sum/2=1 可以判断有carry 1(sum= 2 或者 3)
	Have to match the format when we use insert method in string: 
	string.insert(a.begin, 'char')
	string.insert(0, "string2")






